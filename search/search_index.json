{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Codellm-Devkit (aka. CLDK) is a multilingual program analysis framework that bridges the gap between traditional static analysis tools and Large Language Models (LLMs) specialized for code (CodeLLMs). CLDK simplifies multi-language code analysis by providing a unified Python library that integrates outputs from various analysis tools and prepares them for effective use by CodeLLMs.</p> <p>CLDK streamlines the process of transforming raw code into actionable insights, enabling robust analysis pipelines and seamless integration with tools like WALA, Tree-sitter, LLVM, and CodeQL.</p>"},{"location":"#developer-guide","title":"Developer Guide","text":"<p>Get started with Codellm-Devkit:</p> <ul> <li> <p>  Quickstart</p> <p>Run through an example to quickly set up CLDK and perform multilingual code analysis.</p> </li> <li> <p>  Installing <code>cldk</code></p> <p>Install and initialize the <code>cldk</code> Python package to start analyzing your codebases.</p> </li> <li> <p>  Core Concepts</p> <p>Explore the key components of CLDK\u2014including data models and analysis backends\u2014that simplify code analysis workflows.</p> </li> <li> <p>  API Reference</p> <p>Developer-focused, detailed API reference documentation for <code>cldk</code>.</p> </li> </ul>"},{"location":"#use-cases","title":"Use Cases","text":"<p>Learn how to leverage CLDK for various code analysis tasks:</p> <ul> <li> <p>  Java Unit Test Generation</p> <p>Understand how to use CLDK to generate unit tests for Java projects.</p> </li> <li> <p> array-string  Summarize Python Projects</p> <p>Learn how to summarize Python projects using CLDK.</p> </li> </ul>"},{"location":"#advanced-topics","title":"Advanced Topics","text":"<p>Dive deeper into advanced topics</p> <ul> <li> <p>  Extending CLDK</p> <p>Learn how to extend CLDK to a new language.</p> </li> <li> <p>  Adding a New Analysis Backend</p> <p>Learn how to add a new analysis backend to CLDK.</p> </li> </ul>"},{"location":"#why-codellm-devkit","title":"Why Codellm-Devkit?","text":"<p>TL;DR</p> <p>CLDK unifies traditional program analysis tools with CodeLLMs, streamlining multi-language code analysis into a single, cohesive framework.</p> <p>Current code analysis often involves juggling multiple disjointed tools and workflows. With Codellm-Devkit, you can:</p> <ul> <li>Unified: Integrate various analysis tools and CodeLLMs into one cohesive framework.</li> <li>Extensible: Easily add support for new tools and evolving LLM platforms.</li> <li>Streamlined: Simplify the transformation of raw code into structured, actionable insights.</li> </ul> <p>By providing a consistent and extensible interface, CLDK reduces friction and accelerates the development of robust analysis pipelines.</p>"},{"location":"#contact","title":"Contact","text":"<p>For any questions, feedback, or suggestions, please contact the authors:</p> Name Email Rahul Krishna i.m.ralk@gmail.com Rangeet Pan rangeet.pan@ibm.com Saurabh Sihna sinhas@us.ibm.com"},{"location":"installing/","title":"Installing <code>cldk</code>","text":"<p><code>CLDK</code> is a Python SDK hosted on PyPI and can be installed using your preferred Python package manager.</p>"},{"location":"installing/#installation","title":"Installation","text":"<p>The Python SDK can be installed directly from PyPI using any Python package manager such as pip, poetry, or uv:</p> <code>pip</code><code>poetry</code><code>uv</code> <pre><code>pip install cldk\n</code></pre> <pre><code>poetry add cldk\n</code></pre> <pre><code>uv add cldk\n</code></pre>"},{"location":"installing/#programming-language-specific-dependencies","title":"Programming Language Specific Dependencies","text":"<p><code>CLDK</code> supports program analysis for multiple languages and requires additional dependencies to support specific languages. The following table lists the additional dependencies required for each language:</p> Python AnalysisJava AnalysisC/C++ AnalysisRust Installation <p>For Python analysis as well as to use the CLDK Python SDK, you will need to install the Python programming language with version 3.11 or later. We recommend using a package manager like pyenv to install and manage Python dependencies.</p> <p>For Java analysis, CLDK relies on a companion project called <code>codeanalyzer</code>. <code>codeanalyzer</code> is a java project and you will therefore need to install the Java Development Kit (JDK) with java version 11 or later.</p> <p>You can use a package manager like SDKMAN to install the JDK. First, install SDKMAN by running the following command:</p> <ul> <li> <p>To install <code>SDKMan</code>, open your terminal and enter the following command and follow the instructions to complete the installation:</p> <pre><code>curl -s \"https://get.sdkman.io\" | bash\n</code></pre> </li> <li> <p>Open a new terminal or source the SDKMan! scripts:</p> <pre><code>source \"$HOME/.sdkman/bin/sdkman-init.sh\"\n</code></pre> </li> </ul> <p>Next, install java 11 or later using SDKMAN:</p> <ul> <li> <p>You can list all available java versions with:</p> <pre><code>sdk list java | grep sem\n</code></pre> <p>You should see something like this: <pre><code>Semeru      |     | 21.0.5       | sem     |            | 21.0.5-sem\n            |     | 17.0.13      | sem     |            | 17.0.13-sem\n            |     | 11.0.25      | sem     |            | 11.0.25-sem\n            |     | 8.0.432      | sem     |            | 8.0.432-sem\n</code></pre></p> </li> <li> <p>Install Java 11 or above (we'll go with <code>11.0.25-sem</code>):</p> <pre><code>sdk install java 11.0.25-sem\n</code></pre> </li> <li> <p>Set Java 11 as the current (or default) Java version:</p> <pre><code>sdk use java 11.0.25-sem\n# If want to default to java 11 for all sessions, use the following command instead:\n# sdk default java 11.0.25-sem\n</code></pre> </li> <li> <p>Verify the installation:</p> <pre><code>java -version\n</code></pre> <p>This should output the version of the installed Java.</p> <pre><code>openjdk 11.0.25 2024-10-15\nIBM Semeru Runtime Open Edition 11.0.25.0 (build 11.0.25+9)\nEclipse OpenJ9 VM 11.0.25.0 (build openj9-0.48.0, JRE 11 Linux amd64-64-Bit Compressed References 20241107_1233 (JIT enabled, AOT enabled)\nOpenJ9   - 1d5831436e\nOMR      - d10a4d553\nJCL      - edded3f65c based on jdk-11.0.25+9)\n</code></pre> </li> </ul> <p>Finally, to enable building Java projects automatically, you will need to install the <code>maven</code> build tool. You can install <code>maven</code> using a package manager like <code>SDKMAN</code>:</p> <ul> <li> <p>Install Maven:</p> <pre><code>sdk install maven\n</code></pre> </li> <li> <p>Make sure <code>mvn</code> command is available in the <code>PATH</code>. If <code>mvn</code> is not in your path, add the following to your <code>~/.zshrc</code>, <code>~/.bashrc</code> or <code>~/.bash_profile</code> file:</p> <p><pre><code>export PATH=\"$HOME/.sdkman/candidates/maven/current/bin:$PATH\"\n</code></pre> Then, source the file to apply the changes:</p> <pre><code>source ~/.zshrc # or ~/.bashrc or ~/.bash_profile\n</code></pre> </li> <li> <p>Verify the installation:</p> <p><pre><code>mvn -version\n</code></pre> This should output the version of the installed Maven.</p> </li> </ul> <p>CLDK uses LLVM and Clang Python bindings to analyze C/C++ code. The project requires specific versions:</p> <ul> <li>libclang &gt;= 18.1.1</li> <li>clang &gt;= 17.0.6</li> </ul> <p>You can install LLVM and Clang using various package managers depending on your operating system.</p> macOSUbuntu/DebianRed Hat-based Systems (Fedora/CentOS/RHEL) <ul> <li> <p>Install LLVM 18 using Homebrew <pre><code>brew install llvm@18\n</code></pre></p> </li> <li> <p>Add LLVM to your PATH (add this to your ~/.zshrc or ~/.bash_profile) <pre><code>export PATH=\"/usr/local/opt/llvm@18/bin:$PATH\"\nexport LDFLAGS=\"-L/usr/local/opt/llvm@18/lib\"\nexport CPPFLAGS=\"-I/usr/local/opt/llvm@18/include\"\n</code></pre></p> </li> <li> <p>Verify installation <pre><code>clang --version\n</code></pre> This should output the version of the installed LLVM and Clang. <pre><code>Apple clang version 18.1.1\nTarget: x86_64-apple-darwin21.6.0\nThread model: posix\nInstalledDir: /usr/local/opt/llvm@18/bin\n</code></pre></p> </li> </ul> <ul> <li> <p>Add LLVM repository and install required packages <pre><code>wget https://apt.llvm.org/llvm.sh\nchmod +x llvm.sh\nsudo ./llvm.sh 18\nsudo apt-get install llvm-18 llvm-18-dev clang-18 libclang-18-dev\n</code></pre></p> </li> <li> <p>Create symlinks (optional but recommended) <pre><code>sudo ln -s /usr/bin/clang-18 /usr/bin/clang\nsudo ln -s /usr/bin/llvm-config-18 /usr/bin/llvm-config\n</code></pre></p> </li> <li> <p>Verify installation <pre><code>clang --version\n</code></pre> This should output the version of the installed LLVM and Clang. <pre><code>Ubuntu clang version 18.1.1\nTarget: x86_64-pc-linux-gnu\nThread model: posix\nInstalledDir: /usr/bin\n</code></pre></p> </li> </ul> <ul> <li> <p>Install LLVM 18 and development packages <pre><code># On Fedora\nsudo dnf install llvm18 llvm18-devel clang18 clang18-devel\n\n# On CentOS/RHEL (if needed)\nsudo yum install epel-release\nsudo yum install llvm18 llvm18-devel clang18 clang18-devel\n</code></pre></p> </li> <li> <p>Create symlinks (optional but recommended) <pre><code>sudo ln -s /usr/bin/clang-18 /usr/bin/clang\nsudo ln -s /usr/bin/llvm-config-18 /usr/bin/llvm-config\n</code></pre></p> </li> <li> <p>Verify installation <pre><code>clang --version\n</code></pre> This should output the version of the installed LLVM and Clang. <pre><code>clang version 18.1.8 (Fedora 18.1.8-5.fc41)\nTarget: x86_64-redhat-linux-gnu\nThread model: posix\nInstalledDir: /usr/bin\nConfiguration file: /etc/clang18/x86_64-redhat-linux-gnu-clang.cfg\n</code></pre></p> </li> </ul> <p>Rustup is the recommended tool for installing Rust and managing its toolchains. It simplifies the process of keeping Rust up to date and allows switching between different Rust versions and toolchains seamlessly.</p> <ul> <li> <p>Install Rustup Run the following command in your terminal: <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> Follow the on-screen instructions to complete the installation.</p> </li> <li> <p>Configure Your Environment Add Rust to your PATH by appending this line to your shell init script: <pre><code>source $HOME/.cargo/env\n</code></pre></p> </li> <li> <p>Verify Installation Confirm that Rust is installed correctly by checking the version: <pre><code>rustc --version\n</code></pre> Expected output (version may vary): <pre><code>rustc 1.70.0 (90c541806 2023-05-31)\n</code></pre></p> </li> </ul>"},{"location":"installing/#additional-development-tools","title":"Additional Development Tools","text":"<p>Some operating systems may require additional development tools:</p> macOSUbuntu/DebianRed Hat-based Systems (Fedora/CentOS/RHEL) <ul> <li> <p>Make sure you have the Xcode Command Line Tools installed. You can install them using the following command:</p> <pre><code>xcode-select --install\n</code></pre> </li> <li> <p>Additionally, you may need to install the following packages using Homebrew:</p> <pre><code>brew install openssl readline sqlite3 xz zlib tcl-tk libffi\n</code></pre> </li> </ul> <ul> <li> <p>Install the required development tools using the following command:</p> <pre><code>sudo apt-get install build-essential python3-dev libssl-dev zlib1g-dev \\\nlibbz2-dev libreadline-dev libsqlite3-dev curl git \\\nlibncursesw5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev\n</code></pre> </li> </ul> <ul> <li> <p>Install the required development tools using the following command:</p> <pre><code>sudo dnf group install c-development development-tools gcc make \\\npatch zlib-devel bzip2 bzip2-devel readline-devel sqlite sqlite-devel\\\nopenssl-devel tk-devel libffi-devel xz-devel\n</code></pre> </li> </ul>"},{"location":"installing/#supported-python-versions","title":"Supported Python Versions","text":"<p><code>CLDK</code> is compatible with Python versions 3.11 and later. The following table lists the supported Python versions and the corresponding <code>CLDK</code> versions:</p>  Python Version  Compatible <code>cldk</code> Versions 3.11 \u22650.4.0"},{"location":"quickstart/","title":"Quickstart","text":"<p>Build code analysis pipelines with LLMs in minutes.</p> <p>In this quickstart guide, we will use the Apache Commons CLI example  codebase to demonstrate code analysis pipeline creation using CLDK, with both local LLM inference and automated code processing.</p> Installing CLDK and Ollama <p>This quickstart guide requires CLDK and Ollama. Follow these instructions to set up your environment:</p> <p>First, install CLDK and Ollama Python SDK:</p> <code>pip</code><code>poetry</code><code>uv</code> <pre><code>pip install cldk ollama\n</code></pre> <pre><code>poetry add cldk ollama\n</code></pre> <pre><code>poetry add cldk ollama\n</code></pre> <p>Then, install Ollama:  </p> Linux/WSLmacOS <p>Run the following command:</p> <pre><code>curl -fsSL https://ollama.com/install.sh | sh\n</code></pre> <p>Run the following command:</p> <pre><code>curl -fsSL https://ollama.com/install.sh | sh\n</code></pre> <p>Or, download the installer from here.</p>"},{"location":"quickstart/#step-1-set-up-ollama-server","title":"Step 1: Set Up Ollama Server","text":"<p>Model inference with CLDK starts with a local LLM server. We'll use Ollama to host and run the models.</p> Linux/WSLmacOS <ul> <li> <p>Check if the Ollama server is running:     <pre><code>sudo systemctl status ollama\n</code></pre></p> </li> <li> <p>If not running, start it:     <pre><code>sudo systemctl start ollama\n</code></pre></p> </li> </ul> <p>On macOS, Ollama runs automatically after installation. </p> <p>You can check the status with: <pre><code>launchctl list | grep \"ollama\"\n</code></pre></p>"},{"location":"quickstart/#step-2-pull-the-code-llm","title":"Step 2: Pull the code LLM.","text":"<ul> <li> <p>Let's use the Granite 8b-instruct model for this tutorial:     <pre><code>ollama pull granite-code:8b-instruct\n</code></pre></p> </li> <li> <p>Verify the installation:     <pre><code>ollama run granite-code:8b-instruct 'Write a function to print hello world in python'\n</code></pre></p> <p>You should see a response like: <pre><code>\u276f ollama run granite-code:8b-instruct 'Write a function to print hello world in python'\n    ```python\n        def say_hello():\n            print(\"Hello World!\")\n    ```\n</code></pre></p> </li> </ul>"},{"location":"quickstart/#step-3-download-sample-codebase","title":"Step 3: Download Sample Codebase","text":"<p>We'll use Apache Commons CLI as our example Java project:</p> <pre><code>wget https://github.com/apache/commons-cli/archive/refs/tags/rel/commons-cli-1.7.0.zip -O commons-cli-1.7.0.zip &amp;&amp; unzip commons-cli-1.7.0.zip\n</code></pre> <p>Let's set the project path for future reference: <pre><code>export JAVA_APP_PATH=/path/to/commons-cli-1.7.0\n</code></pre></p> About the Sample Project <p>Apache Commons CLI provides an API for parsing command line options. It's a well-structured Java project that demonstrates various object-oriented patterns, making it ideal for code analysis experiments.</p>"},{"location":"quickstart/#step-3-create-analysis-pipeline","title":"Step 3: Create Analysis Pipeline","text":"What should I expect? <p>In about 40 lines of code, we will use CLDK to build a code summarization pipeline that leverages LLMs to generate summaries for a real world Java project! Without CLDK, this would require multiple tools and a much more complex setup.</p> <p>Let's build a pipeline that analyzes Java methods using LLMs. Create a new file <code>code_summarization.py</code>:</p> code_summarization.py<pre><code>import ollama\nfrom cldk import CLDK\nfrom pathlib import Path\nimport os\n\n# Create CLDK object, specify language as Java.\ncldk = CLDK(language=\"java\")  #  (1)!\n\n# Create analysis object\nanalysis = cldk.analysis(project_path=os.getenv(\"JAVA_APP_PATH\"))  #  (2)!\n\n# Iterate over files\nfor file_path, class_file in analysis.get_symbol_table().items():\n    # Iterate over classes\n    for type_name, type_declaration in class_file.type_declarations.items():\n        # Iterate over methods\n        for method in type_declaration.callable_declarations.values():  #  (3)!\n            # Skip constructors\n            if method.is_constructor:\n                continue\n            # Get code body\n            code_body = Path(file_path).absolute().resolve().read_text()\n\n            # Initialize treesitter\n            tree_sitter_utils = cldk.tree_sitter_utils(source_code=code_body)  # (4)!\n\n            # Sanitize class \n            sanitized_class = tree_sitter_utils.sanitize_focal_class(method.declaration)  # (5)!\n\n            # Format instruction\n            instruction = (\n                f\"Question: Can you write a brief summary for the method \" \n                f\"`{method.declaration}` in the class `{type_name}` below?\\n\\n\" \n                f\"```java\\n{sanitized_class}```\\n\"\n            )\n\n            # Prompt Ollama\n            summary = ollama.generate(\n                model=\"granite-code:8b-instruct\", # (6)!\n                prompt=instruction).get(\"response\") \n\n            # Print output\n            print(f\"\\nMethod: {method.declaration}\")\n            print(f\"Summary: {summary}\")\n</code></pre> <ol> <li>Create a new instance of the CLDK class</li> <li>Create an <code>analysis</code> instance for the Java project. This object will be used to obtain all the analysis artifacts from the java project.</li> <li>In a nested loop, we can quickly iterate over the methods in the project and extract the code body.</li> <li>CLDK comes with a number of treesitter based utilities that can be used to extract and manipulate code snippets. </li> <li>We use the <code>sanitize_focal_class()</code> method to extract the focal class for the method and sanitize any unwanted code in just one line of code.</li> <li>We use the <code>granite-code:8b-instruct</code> model in this example. Try a different model from Ollama model library.</li> </ol>"},{"location":"quickstart/#running-code_summarizationpy","title":"Running <code>code_summarization.py</code>","text":"<p>Save the file as <code>code_summarization.py</code> and run it: <pre><code>python code_summarization.py\n</code></pre></p> <p>You'll see output like: <pre><code>Method: parse\nSummary: This method parses command line arguments using the specified Options object...\n\nMethod: validateOption\nSummary: Validates if an option meets the required criteria including checking...\n\n...\n</code></pre></p>"},{"location":"quickstart/#step-5-customize-analysis","title":"Step 5: Customize Analysis","text":"<p>The pipeline can be customized in several ways:</p> Change ModelModify Prompt <p>Try different Granite model sizes: <pre><code>summary = ollama.generate(\n    model=\"granite-code:34b-instruct\",  # Larger model! \n    prompt=instruction).get(\"response\") \n</code></pre></p> <p>Adjust the task to generate a unit test: <pre><code>def format_inst(code, focal_method, focal_class):\n    return (f\"Generate a complete unit test case using junit4 for the method `{focal_method}`...\\n\\n\"\n            f\"```java\\n{code}```\\n\")\n</code></pre></p>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Explore different analysis tasks like code repair, translation, test generation, and more...</li> <li>Create richer prompts with more analysis artifacts that CLDK provides.</li> <li>Implement batch processing for larger projects, or use the CLDK SDK to build custom analysis pipelines.</li> </ul>"},{"location":"core-concepts/","title":"Core Concepts","text":"<p>To be updated.</p>"},{"location":"reference/","title":"API Reference","text":"<p>To be updated.</p>"}]}